/// <reference types="node" />
/// <reference types="node" />
import PQueue from 'p-queue';
import { EventEmitter } from 'node:events';
import type { Region } from '..';
export declare enum Events {
    CHECK_REGISTERED = "CHECK_REGISTERED",
    CHECK_INPROGRESS = "CHECK_INPROGRESS",
    CHECK_ATTEMPT_RESULT = "CHECK_ATTEMPT_RESULT",
    CHECK_FAILED = "CHECK_FAILED",
    CHECK_SUCCESSFUL = "CHECK_SUCCESSFUL",
    CHECK_FINISHED = "CHECK_FINISHED",
    RUN_STARTED = "RUN_STARTED",
    RUN_FINISHED = "RUN_FINISHED",
    ERROR = "ERROR",
    MAX_SCHEDULING_DELAY_EXCEEDED = "MAX_SCHEDULING_DELAY_EXCEEDED"
}
export type PrivateRunLocation = {
    type: 'PRIVATE';
    id: string;
    slugName: string;
};
export type PublicRunLocation = {
    type: 'PUBLIC';
    region: keyof Region;
};
export type RunLocation = PublicRunLocation | PrivateRunLocation;
export type CheckRunId = string;
export type SequenceId = string;
export declare const DEFAULT_CHECK_RUN_TIMEOUT_SECONDS = 600;
export default abstract class AbstractCheckRunner extends EventEmitter {
    checks: Map<SequenceId, {
        check: any;
    }>;
    testSessionId?: string;
    timeouts: Map<SequenceId, NodeJS.Timeout>;
    schedulingDelayExceededTimeout?: NodeJS.Timeout;
    accountId: string;
    timeout: number;
    verbose: boolean;
    queue: PQueue;
    constructor(accountId: string, timeout: number, verbose: boolean);
    abstract scheduleChecks(checkRunSuiteId: string): Promise<{
        testSessionId?: string;
        checks: Array<{
            check: any;
            sequenceId: SequenceId;
        }>;
    }>;
    run(): Promise<void>;
    private configureResultListener;
    private processMessage;
    processCheckResult(result: any): Promise<void>;
    private allChecksFinished;
    private setAllTimeouts;
    private disableAllTimeouts;
    private startSchedulingDelayTimeout;
    private disableTimeout;
    private getShortLinks;
}
